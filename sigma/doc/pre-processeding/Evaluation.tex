%!TEX root = ttc16-cra-sigma.tex

\section{Evaluation}
\label{sec:Evaluation}

In this section we provide an evaluation of our solution following the categories given by the case study description.
We leave the complexity and flexibility characteristics to be evaluated by reviewers.
All the presented results are based on the NSGA-III algorithm. 
More results are provided on the github page.

\Paragraph{Completeness \& Correctness}
The solution always converts a valid input RDG into a class model.
The three constraints that were imposed by the solution description are solved as follows:
%
\begin{compactitem}[---]
  \item \emph{Every class must have a unique name.} 
  The new classes are created in a loop that iterates over a number range.
  Part of the class name is the iteration variable and thus it must be always unique.
  \item \emph{All features provided in the input model must be encapsulated by a class.} 
  This has been already explained in the previous section.
  This is a property of the problem mapping we have chosen.
  \item \emph{There cannot be any empty classes.}
  We explicitly filter out empty classes.
\end{compactitem}

\Paragraph{Optimality}
The following table shows the cohesion and coupling rations as well as the resulting CRA-Index:
\begin{center}
\begin{tabular}{crrr}
\hline
\textbf{Input} & \textbf{Cohesion} & \textbf{Coupling} & \textbf{CRA} \\ \hline
A           & 4        & 1        & 3         \\
B           & 6.5      & 2.5      & 4         \\
C           & 6.37     & 3.63     & 2.74      \\
D           & 4.83     & 7.94     & -3.11     \\
E           & 7.38     & 17.99    & -10.60    \\
F           & 9.85     & 44.74    & -34.88    \\ \hline
\end{tabular}
\end{center}


\Paragraph{Performance}
The solution completion time from the SHARE environment for the input models is presented in the table below:
\begin{center}
\begin{tabular}{cr}
\hline
\textbf{Input} & \textbf{Time {[}s{]}} \\
\hline
A              & 19.17                 \\
B              & 34.78                 \\
C              & 72.53                 \\
D              & 300.49                \\
E              & 1110.74               \\
F              & 6289.75              \\ 
\hline
\end{tabular}
\end{center}

% \subsection{Conciseness}

% The solution itself consists of 52 lines of Scala code the internal DSL developed for this case study.
% The DSL itself has been implemented using 20 lines of Scala code using \SIGMA.
% The integration part consists of three files with the total of 65 lines.
% All measures are source lines only excluding comments and new lines.
% Given these measures, we believe that the code is quite concise.

% \subsection{Readability}

% Next to being concise, the solution is also quite expressive.
% This means that the given problem (queries and repair transformations) naturally maps into the implementation.
% The higher-level abstraction provided by both \SIGMA and the internal DSLs helps to facilitate it making a significant improvement over the Java reference implementation.
% % It is important to note that we could have provided even a more flexible syntax, but that would obscure the implementation of the DSL (the type definition) and make the possible error messages more cryptic.
% %
% Next to being concise and expressive, the code is also type-safe as Scala is statically typed language.
% A notable consequence is that it is very easy to use the DSL with an IDE like Eclipse or IntelliJ that provides a robust code completing functionalities, outline views and other features increasing one's productivity.

% In summary, while readability is a subjective matter and largely depends on the background and experience of users, we believe that \SIGMA scores well.
% Thanks to the syntax of Scala which is close to one of Java/C++ and hence shall be familiar to many developers.
% The expressiveness of the first-order logic collection operation should be familiar to anyone knowing OCL or any other function language.


% \subsection{Performance on Large Models}

% The tests have been performed on an 2.3 GHz Intel Core i7 machine with 16 GB of RAM being dedicated to the JVM process.
% We ran our solution together with the reference implementation in Java.
% We used the model instances from size 1 to 8192 and set 8GB memory to be dedicated to the JVM.
% The corresponding results are shown in the figures~\ref{fig:SigmaFixedValidationBatch} and~\ref{fig:SigmaFixedReValidationBatch}.
% We compare them to the Java solution which is shown in the figures~\ref{fig:JavaFixedValidationBatch} and~\ref{fig:JavaFixedReValidationBatch}.
% We get a similar performance which has been expected due to the fact that Scala compiles directly to Java bytecode and we use the same underlying libraries for accessing EMF models.
% This shows that we can leverage from concise and expressive queries without sacrificing performance.

% It is important to note that we do not developed any extra functionality for these benchmarks---\Ie no caching or incremental validations.
% On the other hand, functional approach we have selected makes it perfect for further parallelization.
% Moreover, for even larger models we could easily port the solution into big data analysis platforms such as Hadoop\footnote{\url{https://hadoop.apache.org/}}.
% This would be rather difficult given the imperative Java implementation.

% \begin{figure}[h!tb]
%   \centering
%   \includegraphics[width=\textwidth]{figures/fixed-Sigma-GroupBy-Query-time-batch-validation.pdf}
%   \caption{\SIGMA fixed validation batch}
%   \label{fig:SigmaFixedValidationBatch}
% \end{figure}

% \begin{figure}[h!tb]
%   \centering
%   \includegraphics[width=\textwidth]{figures/fixed-Sigma-GroupBy-Query-time-revalidation.pdf}
%   \caption{\SIGMA fixed revalidation}
%   \label{fig:SigmaFixedReValidationBatch}
% \end{figure}

% \begin{figure}[h!tb]
%   \centering
%   \includegraphics[width=\textwidth]{figures/fixed-Java-GroupBy-Query-time-batch-validation.pdf}
%   \caption{Java fixed validation batch}
%   \label{fig:JavaFixedValidationBatch}
% \end{figure}

% \begin{figure}[h!tb]
%   \centering
%   \includegraphics[width=\textwidth]{figures/fixed-Java-GroupBy-Query-time-revalidation.pdf}
%   \caption{Java fixed revalidation}
%   \label{fig:JavaFixedReValidationBatch}
% \end{figure}

% \clearpage
